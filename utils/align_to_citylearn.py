"""
This scripts aligns the output of DesignBuilder building simulation to the expected input into CityLearn.
Currently, the `cooling_demand` and `dhw_demand` cols are generated indirectly, not an output of the simulation.
Reason is, the demands generated by the simulation contain lots of zeros. That is because the scheduling mechanism of
DesignBuilder is very static (e.g. values are repeated often between days.)
"""
import pandas as pd
import numpy as np

def compute_cooling_demand(temp_c):
    """
    Return cooling demand in kWh for a 1-h step.

    - Set-point: 22 °C
    - Nothing below 20 °C
    - Between 20-22 °C: tiny stochastic load
    - Above 22 °C: linear ramp chosen so the villa hits ~70 kW at 45 °C
    """
    if temp_c < 20:
        return 0.0
    elif temp_c < 22:
        return np.random.normal(0.12, 0.03)       # small latent load
    else:
        # slope chosen so (45 °C gives 72 kWh)
        slope = 3.1
        noise  = np.random.normal(0, 0.4)
        return (temp_c - 22) * slope + noise


def compute_non_shiftable_load(df): 
    """
    Computes the non-shiftable loads of a building, and adds some noise on a daily and hourly basis.
    """
    # Calculate non-shiftable load from internal loads
    df['non_shiftable_load'] = (
        df['Room Electricity'].astype(float).fillna(0) +
        df['Lighting'].astype(float).fillna(0) +
        df['Computer + Equip'].astype(float).fillna(0) +
        df['Miscellaneous'].astype(float).fillna(0)
    )

    # Daily scaling
    daily_scaling = np.random.normal(1.0, 0.05, size=(len(df) // 24))
    # Hourly scaling
    hourly_noise = np.random.normal(1.0, 0.02, size=len(df))
    # Combine scaling
    combined_scaling = np.repeat(daily_scaling, 24)[:len(df)] * hourly_noise

    # Hourly shaping curves
    weekday_shape = np.array([
        0.5 if 0 <= h <= 5 else       # early morning
        0.8 if 6 <= h <= 8 else       # morning prep
        0.6 if 9 <= h <= 16 else      # work hours
        1.0 if 17 <= h <= 22 else     # evening peak
        0.7 for h in range(24)        # late night
    ])

    weekend_shape = np.array([
        0.4 if 0 <= h <= 6 else       # sleepy morning
        0.9 if 7 <= h <= 10 else      # late wakeup, coffee time
        0.6 if 11 <= h <= 16 else     # chill daytime
        1.1 if 17 <= h <= 22 else     # even more active evenings
        0.8 for h in range(24)        # late night
    ])

    # Apply scaling
    df['non_shiftable_load'] *= combined_scaling

    # Apply hourly shaping based on day_of_week (Sunday=1, ..., Saturday=7)
    df['non_shiftable_load'] *= [
        weekend_shape[h] if dt in (1, 7) else weekday_shape[h]
        for h, dt in zip(df['hour'], df['day_type'])
    ]


def compute_dhw_demand(hour, day_type, occupants=5):
    """
    Return DHW demand in kWh for a 1-h step.
    - hour: current hour
    - day_type: 1..7 (1=Sunday, 2=Monday, ..., 7=Saturday)
    - occupants: scale demand for more / fewer people
    """
    is_weekend = day_type in (1, 7)
    if 5 <= hour <= 8:       # morning showers
        usage_prob = 0.70 if is_weekend else 0.85
        mu, sigma = 0.8, 0.4
    elif 12 <= hour <= 13:   # lunchtime wash-up
        usage_prob = 0.55 if is_weekend else 0.45
        mu, sigma = 0.35, 0.25
    elif 18 <= hour <= 22:   # evening showers & dishes
        usage_prob = 0.95 if is_weekend else 0.90
        mu, sigma = 1.0, 0.5
    else:                    # idle hours
        usage_prob = 0.08 if is_weekend else 0.05
        mu, sigma = 0.03, 0.01             # rare small “real” uses
        trickle_mean, trickle_sd = 0.02, 0.006  # baseline trickle

    if np.random.rand() < usage_prob:
        # scale by occupant count; log-normal generates positive skew
        kwh = np.random.lognormal(mean=mu, sigma=sigma) * (occupants / 6)
    else:
        # Gamma trickle with mean=trickle_mean and sd=trickle_sd (always >= 0)
        # (only defined/used in idle hours; for non-idle, these variables won’t be read)
        if 'trickle_mean' in locals():
            m, s = trickle_mean, trickle_sd
        else:
            # non-idle hours: keep a tiny positive baseline to avoid exact zeros
            m, s = 0.005, 0.002
        k = (m / s) ** 2           # shape
        theta = (s ** 2) / m       # scale
        kwh = np.random.gamma(shape=k, scale=theta)

    # clamp & round to kill float fuzz
    if abs(kwh) < 1e-6:
        kwh = 0.0
    return float(round(kwh, 6))




def load_and_transform_building(path: str, b_number: int):
    """
    Loads the simulated building output from DesignBuilder, and aligns it for 
    CityLearn input.
    """
    df = pd.read_csv(path, header=0)
    df = df.drop(index=0).reset_index(drop=True) # Drop units row
    
    # Parse datetime
    df['datetime'] = pd.to_datetime(df['Date/Time'], format="mixed")
    df['month'] = df['datetime'].dt.month
    df['hour'] = df['datetime'].dt.hour
    df['day_type'] = df['datetime'].dt.isocalendar().day.astype(int)

    # Overwrite or smooth dhw_demand
    df['dhw_demand'] = [
        compute_dhw_demand(h, dt) for h, dt in zip(df['hour'], df['day_type'])
    ]

    compute_non_shiftable_load(df)

    # Final CityLearn-aligned DataFrame
    citylearn_df = pd.DataFrame({
        'month': df['month'],
        'hour': df['hour'],
        'day_type': df['day_type'],
        'cooling_demand': df['Operative Temperature'].astype(float).apply(compute_cooling_demand).fillna(0).clip(lower=0).round(6),
        'dhw_demand': pd.to_numeric(df['dhw_demand'], errors='coerce').fillna(0).clip(lower=0).round(6),
        'non_shiftable_load': df['non_shiftable_load'],
        'occupant_count': df['Occupancy'].astype(float),
        'indoor_dry_bulb_temperature': df['Operative Temperature'].astype(float),
        'indoor_relative_humidity': df['Relative Humidity'].astype(float)
    })


    # Sa    udi building cooling setpoints - 22°C base with practical variations
    weekend = df['day_type'].isin([6, 7])
    nighttime = (df['hour'] < 7) | (df['hour'] >= 23)  # 11 PM - 7 AM
    work_hours = (df['hour'] >= 9) & (df['hour'] <= 17)  # 9 AM - 5 PM

    # Base setpoint: 22°C for comfort during occupied hours
    # Higher setpoints during sleep/away periods for energy savings
    cooling_sp = np.where(
        nighttime,
        24.0 + 1.0 * weekend.astype(float),  # 24-25°C at night (sleep setback)
        np.where(
            work_hours & ~weekend,
            22.0,  # 22°C during work hours on weekdays (occupied comfort)
            22.5 + 0.5 * weekend.astype(float)  # 22.5-23°C other times
        )
    )

    # Add small daily variation to make it more realistic
    daily_variation = np.sin(2 * np.pi * df['day_type'] / 7) * 0.3  # ±0.3°C weekly cycle
    cooling_sp += daily_variation

    citylearn_df['indoor_dry_bulb_temperature_cooling_set_point'] = np.round(cooling_sp, 1)

    citylearn_df['hvac_mode'] = np.where(citylearn_df['cooling_demand'] > 1e-6, 1, 0).astype(int)
    citylearn_df['heating_demand'] = 0
    citylearn_df['solar_generation'] = 0

    citylearn_df.to_csv(f"data/building_{b_number}.csv", index=False)
    print(f"Processed building_{b_number} and saved it.")

if __name__ == "__main__":
    load_and_transform_building("data/raw/RUH_RES_BUILDING.csv", 1)
    load_and_transform_building("data/raw/JED_RES_BUILDING.csv", 2)
    load_and_transform_building("data/raw/ABH_RES_BUILDING.csv", 3)